'use strict';

const _ = require('lodash');

/**
 * Collapses tabular result sets into a (hierarchical) object graph based on
 * column nomenclature. Given a query that selects parent and child columns as
 * parent__id, parent__val, children__id, children__val, this will return an
 * array of objects in the form
 *
 * {id: 1, val: 'parent val', children: [{id: 11, val: 'child val'}]}
 *
 * and so on.
 *
 * @param  {String} parent - Name of the parent entity, the first part of parent__id.
 * @param  {String} pk - Name of the parent primary key field, also applied to children unless overridden.
 * @param  {Array} data - Array of database records to decompose.
 * @return {Array} An array of nested objects generated by applying the schema
 * to each data element in turn.
 */
exports = module.exports = function (schema, data) {
  if (!data || data.length === 0) {
    return [];
  }

  /* mapping is a nested dictionary of id:entity but otherwise in the form of
   * the final structure we're trying to build, effectively hashing ids to
   * ensure we don't duplicate any entities in cases where multiple dependent
   * tables are joined into the source query.
   *
   * example: {1: {id: 1, name: 'hi', children: {111: {id: 111, name: 'ih'}}} */
  const mapping = data.reduce(function (acc, row) {
    return (function build (obj, schema) {
      const id = row[schema.pk];

      if (id === null) {
        // null id means this entity doesn't exist (eg outer join)
        return undefined;
      } else if (!obj.hasOwnProperty(id)) {
        // this entity is new
        obj[id] = {};
      }

      // the columns object maps field names in the row to object key names
      _.map(schema.columns, (val, key) => {
        obj[id][val] = row[key];
      });

      Object.keys(schema).forEach(function (c) {
        switch (c) {
          case 'pk': case 'columns': case 'array': break;
          default: {
            const descendant = build(obj[id][c] || {}, schema[c]);

            if (descendant) {
              obj[id][c] = descendant;
            } else if (schema[c].array) {
              // we always want an array if there could be multiple descendants
              obj[id][c] = [];
            }

            break;
          }
        }
      });

      return obj;
    })(acc, schema);
  }, {});

  /* Build the final graph. The structure and data already exists in mapping,
   * but we need to transform the {id: entity} structures into arrays of
   * entities (or flat objects if required).
   *
   * example: [{id: 1, name: 'hi', children: [{id: 111, name: 'ih'}]}] */
  return (function transform (schema, map, output) {
    // for every id:entity pair in the current level of mapping, if the schema
    // defines any dependent entities recurse and transform them, then push the
    // current object into the output and return
    return Object.keys(map).reduce(function (acc, id) {
      Object.keys(schema)
        .filter(c => {
          return c !== 'columns' && typeof schema[c] === 'object';  // just structure now
        })
        .forEach(function (node) {
          // we have to init & pass the accumulator into the *next* recursion
          // since the single option is defined on the child rather than the
          // parent
          const accumulator = schema[node] && schema[node].array ? [] : {};

          if (map[id][node]) {
            map[id][node] = transform(schema[node], map[id][node], accumulator);
          }
        });

      if (Array.isArray(output)) {
        acc.push(map[id]);
      } else {
        acc = map[id];
      }

      return acc;
    }, []);
  })(schema, mapping, []);
};
