# Persistence

Massive's lack of entity modeling means it retrieves your data in the form of plain JavaScript objects and arrays, and _storing_ your data is no different. The use of objects instead of models makes persistence an extremely flexible proposition: you can write what you want when you want and, unlike with object-relational models, ignore anything you don't know yet as long as it's not required by table constraints. The persistence methods operate only on the columns you specify, and leave all others with the existing or default value, as appropriate.

## save

`save` performs an upsert. On initialization, Massive records your tables' primary key information and uses this to determine whether the object passed to `save` represents a new or an existing row and invokes `insert` or `update` appropriately. The promise `save` returns will resolve to the created or modified record represented as an object.

`save` may not be used with foreign tables, since they do not have primary keys to test.

[Query options](/options) for `INSERT` and `UPDATE` statements, and for results processing, may be used with `save` as a second argument. However, most of these are of limited utility.

```javascript
db.tests.save({
  version: 1,
  name: 'homepage'
}).then(tests => {
  // the newly-inserted test
});

db.tests.save({
  id: 1,
  version: 2,
  priority: 'high'
}).then(tests => {
  // the updated test, still with the name 'homepage'
});
```

### insert

`insert` writes an object into your table. The object's keys should match your column names exactly. You do not have to perform a complete insert and specify every single field in your object; as long as you ensure that no `NOT NULL` constraints will be violated, you can include as many or as few fields as you need. When you insert an object, the record will be returned as an object. If you have an autogenerated or serial primary key or default fields, they will have been calculated and added.

```javascript
db.tests.insert({
  name: 'homepage',
  version: 1,
}).then(test => {
  // the newly-inserted test
});
```

You can insert multiple rows at once -- just pass an array, and you'll receive an array containing all your new records:

```javascript
db.tests.insert([{
  name: 'homepage',
  version: 1,
  priority: 'low'
}, {
  name: 'about us',
  version: 1
}]).then(tests => {
  // an array containing both newly-inserted tests
});
```

Records in the array may omit keys if the database default value is intended; however, fields having `NOT NULL` constraints must be included or the insert will fail.

[Query options](/options) for `INSERT` statements and results processing may be used with `insert`:

```javascript
db.tests.insert({
  name: 'homepage',
  version: 1,
}, {
  onConflictIgnore: true, // add ON CONFLICT DO NOTHING to the query
}).then(test => {
  // the inserted row, or `null` if there was a conflict and nothing was inserted
});
```

## update

`update` has two variants. Passed an object with a value for the table's primary key field, it updates all included fields of the object based on the primary key; or, passed a criteria object and a changes map, it applies all changes to all rows matching the criteria. Only the criteria-changes variant can be used with foreign tables.

Both `update` functions return promises for the updated data. If given a single object, the promise will resolve to the updated object or `null` if the primary key was not found. If passed both criteria and changes objects to perform a bulk update, it will resolve to an array of records, even if no or only one record was actually modified.

```javascript
db.tests.update({
  id: 1,
  version: 2,
  priority: 'high'
}).then(test => {
  // the updated test
});

db.tests.update({
  priority: 'high'
}, {
  priority: 'moderate'
}).then(tests => {
  // an array containing all tests which formerly had
  // priority 'high'. Since this issues a prepared
  // statement, note that the version field cannot
  // be incremented here!
});
```

Both versions of `update` can take [query options](/options) for `UPDATE` statements and for results processing:

```javascript
db.tests.update({
  id: 1,
  version: 2,
  priority: 'high'
}, {build: true}).then(test => {
  // builds the query without executing it
});
```

## destroy

`destroy` removes data either by primary key or by matching a criteria object. In the former case, it returns a promise for the deleted record object; in the latter, it returns a promise for an array containing all deleted records, even if no or one records were deleted.

[Query options](/options) for `DELETE` statements and results processing may be used with `destroy`.

```javascript
db.tests.destroy(1).then(test => {
  // test #1
});

db.tests.destroy({
  priority: 'high'
}, {only: true}).then(tests => {
  // an array containing all removed tests; the 'only' flag
  // prevents the query from affecting descendant tables
});
```
