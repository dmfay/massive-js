# Persistence

Massive's lack of entity modeling means it retrieves your data in the form of plain JavaScript objects and arrays, and _storing_ your data is no different. The use of objects instead of models makes persistence an extremely flexible proposition: you can write what you want when you want and, unlike with object-relational models, ignore anything you don't know. The persistence methods operate only on the columns you specify, and leave all others with the existing or default value, as appropriate.

## save

`save` performs an upsert. On initialization, Massive records your tables' primary key information and uses this to determine whether the object passed to `save` represents a new or an existing row and invokes `insert` or `update` appropriately. The promise `save` returns will resolve to the created or modified record represented as an object.

`save` may not be used with foreign tables, since they do not have primary keys to test.

```javascript
db.tests.save({
  version: 1,
  name: 'homepage'
}).then(tests => {
  // the newly-inserted test
});

db.tests.save({
  id: 1,
  version: 2,
  priority: 'high'
}).then(tests => {
  // the updated test, still with the name 'homepage'
});
```

### insert

`insert` writes an object into your table. The object's keys should match your column names exactly. You do not have to perform a complete insert and specify every single field in your object; as long as you ensure that no `NOT NULL` constraints will be violated, you can include as many or as few fields as you need. When you insert an object, the record will be returned as an object. If you have an autogenerated or serial primary key or default fields, they will have been calculated and added.

```javascript
db.tests.insert({
  name: 'homepage',
  version: 1,
}).then(test => {
  // the newly-inserted test
});
```

You can insert multiple rows at once -- just pass an array, and you'll receive an array containing all your new records:

```javascript
db.tests.insert([{
  name: 'homepage',
  version: 1
}, {
  name: 'about us',
  version: 1
}]).then(tests => {
  // an array containing both newly-inserted tests
});
```

Either version of `insert` may be passed additional options:

```javascript
db.tests.insert({
  name: 'homepage',
  version: 1,
}, {
  onConflictIgnore: true, // add ON CONFLICT DO NOTHING to the query
}).then(test => {
  // the inserted row, or `null` if there was a conflict and nothing was inserted
});
```

## update

`update` has two variants. Passed an object with a value for the table's primary key field, it updates all included fields of the object based on the primary key; or, passed a criteria object and a changes map, it applies all changes to all rows matching the criteria. Only the criteria-changes variant can be used with foreign tables.

Both `update` functions return promises for the updated data. If given a single object, the promise will resolve to the updated object or `null` if the primary key was not found. If passed both criteria and changes objects to perform a bulk update, it will resolve to an array of records, even if no or only one record was actually modified.

```javascript
db.tests.update({
  id: 1,
  version: 2,
  priority: 'high'
}).then(test => {
  // the updated test
});

db.tests.update({
  priority: 'high'
}, {
  priority: 'moderate'
}).then(tests => {
  // an array containing all tests which formerly had
  // priority 'high'. Since this issues a prepared
  // statement, note that the version field cannot
  // be incremented here!
});
```

As with `insert`, either signature of `update` can be passed options:

```javascript
db.tests.update({
  id: 1,
  version: 2,
  priority: 'high'
}, {build: true}).then(test => {
  // builds the query without executing it
});
```

## destroy

`destroy` removes data matching a criteria object, and returns a promise for an array containing the deleted data.

```javascript
db.tests.destroy({
  priority: 'high'
}).then(tests => {
  // an array containing all removed tests
});
```
