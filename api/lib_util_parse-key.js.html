<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: lib/util/parse-key.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: lib/util/parse-key.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';

/**
 * Parse out a criterion key into something more intelligible. Massive is more
 * flexible than Postgres' query parser, with more alternate aliases for
 * operations and looser rules about quoting, especially with JSON fields. This
 * necessitates some pretty gnarly parsing.
 *
 * @module util/parseKey
 * @param  {String} key A reference to a database column. The field name may be quoted using double quotes to allow names which otherwise would not conform with database naming conventions. Optional components include, in order, [] and . notation to describe elements of a JSON field; ::type to describe a cast; and finally, an argument to the appendix function.
 * @param {Object} appendix A function which when invoked with an optional component of the key returns a value to be used later. So far used for operations (from {@linkcode where}) and ordering (from {@linkcode order}.
 * @return {Object} An object describing the parsed key.
 */
exports = module.exports = function (key, appendix) {
  key = key.trim();

  const jsonShape = [];       // describe a JSON path: true is a field, false an array index
  let elements = [];          // collect actual JSON path elements (for document queries)
  let parsed = [[]];          // we're going to collect token arrays
  let buffer = parsed[0];     // start with the first token
  let inQuotedField = false;  // ensure we pick up everything in quotes
  let hasCast = false;        // make sure we pull the appropriate token for castType
  let i = 0;
  let char = key.charAt(i);

  do {
    if (inQuotedField &amp;&amp; char !== '"') {
      buffer.push(char);
    } else {
      switch (char) {
        case '"':
          // quoted field
          if (i === 0) {
            inQuotedField = true;   // just starting out, use the initial token
          } else {
            inQuotedField = false;  // finishing the quoted field, new token
            buffer = parsed[parsed.push([]) - 1];
          }

          break;

        case ':':
          // cast; new token, but we ignore the : characters since we only care
          // about type
          if (!hasCast) {
            hasCast = true;

            buffer = parsed[parsed.push([]) - 1];
          }

          break;

        case '.':
          // json path traversal. new token, and note that it's a field to ensure
          // proper element/index handling later.
          jsonShape.push(true);
          buffer = parsed[parsed.push([]) - 1];
          break;

        case '[':
          // json array index. new token, and note that it's an index for later.
          jsonShape.push(false);
          buffer = parsed[parsed.push([]) - 1];
          break;

        case ']':
          // terminate json array index. starts a new token, no jsonShape push
          buffer = parsed[parsed.push([]) - 1];
          break;

        case ' ': case '\t': case '\r': case '\n':
          // whitespace; separates tokens
          buffer = parsed[parsed.push([]) - 1];
          break;

        default:    // eslint-disable-line no-fallthrough
          buffer.push(char);
          break;
      }
    }

    i++;
  } while (char = key.charAt(i)); // eslint-disable-line no-cond-assign

  parsed = parsed.reduce(function (acc, p) {
    const str = p.join('').trim();

    if (str) { acc.push(str); }

    return acc;
  }, []);

  const field = parsed.shift();
  let castType, appended;
  let quotedField = `"${field}"`;

  if (jsonShape.length === 1) {
    elements.push(parsed.shift());

    if (jsonShape[0]) {
      // object key
      quotedField = `${quotedField}->>'${elements[0]}'`;
    } else {
      // array index
      quotedField = `${quotedField}->>${elements[0]}`;
    }
  } else if (jsonShape.length > 0) {
    elements = parsed.splice(0, jsonShape.length);

    quotedField = `${quotedField}#>>'{${elements.join(',')}}'`;
  }

  if (hasCast) {
    castType = parsed.shift();

    if (jsonShape.length > 0) {
      quotedField = `(${quotedField})::${castType}`;
    } else {
      quotedField = `${quotedField}::${castType}`;
    }
  }

  if (appendix) {
    // anything remaining goes to appendix

    appended = appendix(parsed.join(' ').toLowerCase());
  }

  return {
    rawField: field,
    field: quotedField,
    elements,
    appended,
    isJSON: jsonShape.length > 0
  };
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-massive.html">massive</a></li><li><a href="module-mutators.html">mutators</a></li><li><a href="module-operations.html">operations</a></li><li><a href="module-util_decompose.html">util/decompose</a></li><li><a href="module-util_docify.html">util/docify</a></li><li><a href="module-util_getFilterString.html">util/getFilterString</a></li><li><a href="module-util_parseKey.html">util/parseKey</a></li><li><a href="module-util_prepareParams.html">util/prepareParams</a></li><li><a href="module-where.html">where</a></li></ul><h3>Classes</h3><ul><li><a href="Database.html">Database</a></li><li><a href="Delete.html">Delete</a></li><li><a href="Entity.html">Entity</a></li><li><a href="Executable.html">Executable</a></li><li><a href="Insert.html">Insert</a></li><li><a href="Readable.html">Readable</a></li><li><a href="Select.html">Select</a></li><li><a href="Sequence.html">Sequence</a></li><li><a href="SingleValueStream.html">SingleValueStream</a></li><li><a href="Update.html">Update</a></li><li><a href="Writable.html">Writable</a></li></ul><h3>Global</h3><ul><li><a href="global.html"></a></li><li><a href="global.html#getDefaultSQLforUUID">getDefaultSQLforUUID</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Wed Feb 06 2019 17:09:10 GMT-0500 (Eastern Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
